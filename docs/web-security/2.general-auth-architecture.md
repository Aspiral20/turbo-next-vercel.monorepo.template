# ðŸ” Secure Token Architecture

```sql
                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                           â”‚      Identity Provider    â”‚
                           â”‚   (Authorization Server)  â”‚
                           â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚
                           â”‚  â€¢ Authenticates user     â”‚
                           â”‚  â€¢ Issues tokens          â”‚
                           â”‚  â€¢ Refresh rotation       â”‚
                           â”‚  â€¢ Revocation store       â”‚
                           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                         â”‚
                       Authorization Code â”‚ (PKCE)
                                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Web / Mobile        â”‚      â”‚ Secure Cookie â”‚
â”‚        Client            â”‚â—€â”€â”€â”€â”€â”€â”‚  Refresh RT   â”‚
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚      â”‚ HttpOnly, ... â”‚
â”‚ â€¢ Access token in memory â”‚      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚ â€¢ Calls APIs             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚ Bearer Access Token
              â–¼
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚    Resource Server /     â”‚
       â”‚           API            â”‚
       â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
       â”‚  â€¢ Validates Access JWT  â”‚
       â”‚  â€¢ Rejects expired/invalid
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚ 401 Unauthorized
                    â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Refresh Token Endpoint   â”‚
        â”‚        (/token)          â”‚
        â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
        â”‚ â€¢ Reads Refresh Token    â”‚
        â”‚   from HttpOnly cookie   â”‚
        â”‚ â€¢ Issues new Access Tokenâ”‚
        â”‚ â€¢ Rotates Refresh Token  â”‚
        â”‚ â€¢ Invalidates old RT     â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â–¼
              New Access Token
              New Refresh Token (cookie)
```

# 1) Architecture (concise, practical)

### Components
- Client (Browser / Mobile) â€” initiates auth, holds short-lived access token in memory (browser) or secure storage (mobile). Refresh token stored only in HttpOnly Secure SameSite cookie for web, or OS secure storage for native apps.
- Authorization Server (AuthN/AuthZ) â€” authenticates users, issues access + refresh tokens, implements refresh token rotation, revocation DB, token introspection endpoint, rate limiting, logging, and anomaly detection.
- Resource Server (API) â€” validates access tokens (JWT signature or introspection of opaque token), enforces scopes and checks token expiry.
- Token Storage / Revocation DB â€” server-side store for refresh token state, rotation nonces, and revocation lists.
- Secure Transport / Ops â€” HTTPS everywhere, HSTS, CSP for web apps, secure cookie flags (HttpOnly, Secure, SameSite), short CORS policy, WAF/rate limiting, monitoring & alerting.
### Key Behaviors
- Issue short-lived access tokens (5â€“15 minutes) and longer-lived refresh tokens (e.g., 7â€“30 days) with rotation.
- Refresh token rotation: each /token call consumes the old refresh token and issues a new one; if a rotated token is reused, immediately revoke session and require re-authentication.
- Revoke on logout: mark refresh token(s) invalid in revocation DB.
- Client types:
  - Confidential servers: use client authentication (client secret or mTLS) at token endpoint.
  - Public clients (SPA, mobile): require PKCE for authorization code flow; use refresh tokens cautiously (use secure cookie or short-lived refresh tokens + rotation).
- Protect token endpoints with rate limits, anomaly detection (geo, device, rapid reuse), and incremental backoff on failure.
- Prefer opaque refresh tokens (server can revoke) or maintain short-lived JWT refresh tokens with revocation capability.
- Avoid storing tokens in localStorage/sessionStorage on webâ€”use memory + refresh via secure cookie.

# 2) Diagram of refresh / access token flow

Components and flow: user authenticates â†’ authorization server sets refresh token cookie â†’ browser uses access token to call API â†’ when access token expires API returns 401 â†’ client POSTs to /token using the refresh cookie â†’ auth server rotates refresh token and issues new access token.

```scss
[Client] --(1. PKCE Auth Request)--------------------> [Authorization Server]
[Client] <--(2. Auth Code Redirect)-------------------
[Client] --(3. Exchange Code for Tokens)-------------> [Auth Server /token]
[Client] <---- Access Token + Refresh Token Cookie ----

[Client] --(4. Call API with Access Token)-----------> [API]
[API] <---- Protected Resource -----------------------

When Access Token Expires:
[Client] --(5. /token with Refresh Cookie)-----------> [Auth Server]
[Client] <---- New Access Token + Rotated Refresh ----

If RT replay detected â†’ session revoked â†’ re-login required.
```

# 3) Minimal example flows / endpoints (pseudo)

```markdown
Client Storage:
  - Access Token â–¸ memory only
  - Refresh Token â–¸ HttpOnly Secure SameSite cookie

Authorization Server DB:
  - refresh_tokens table:
      token_id | user_id | expires | rotated_to | valid?

Resource Server:
  - JWT verification (public key)
  - or opaque token introspection
```

### Authorization (browser SPA)

1. Client â†’ Auth server: GET /authorize?response_type=code&code_challenge=... (PKCE)
2. User authenticates, consents.
3. Auth server â†’ Client: redirect with authorization code.
4. Client â†’ Auth server: POST /token (authorization code + code_verifier) â€”> server issues:
   - Sets RefreshToken cookie: Set-Cookie: refresh=<opaque>; HttpOnly; Secure; SameSite=Strict; Path=/token; Max-Age=2592000 
   - Returns access_token in response body (short TTL).
### Using API
- Client sends Authorization: Bearer <access_token> to Resource Server.
### Refresh
- When access token expired:
  - Client: POST /token (cookie automatically sent)
  - Server: verify refresh token (check rotation nonce), issue:
    - new access_token
    - set Set-Cookie with new refresh token (invalidate old one in DB)
### Logout
- Client â†’ Auth server: POST /logout (include cookie)
- Auth server: revoke refresh token(s) in DB and clear cookie: Set-Cookie: refresh=; Max-Age=0; HttpOnly; Secure; Path=/token